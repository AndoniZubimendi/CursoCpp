\documentclass{beamer}
\special{landscape}

%\usetheme{Berlin}
\usetheme{Warsaw}

%\usecolortheme{seahorse}
%\usefonttheme[onlysmall]{structurebold}

\setbeamertemplate{headline}[split]
\setbeamertemplate{footline}[default]
\setbeamertemplate{footline}[miniframes theme]
%\logo{\includegraphics[scale=0.25]{lifia_logo.png}}

\mode<presentation>
\usepackage[spanish]{babel}
\usepackage{beamerthemesplit}
\usepackage[utf8]{inputenc}
\usepackage{color}      % use if color is used in text

% Comandos en modo Verbatim
%\usepackage{fancyvrb}

\title{Curso C++ - Clase 3}
\author{Juan Antonio Zubimendi\\azubimendi@lifia.info.unlp.edu.ar}

\institute{LIFIA}
%\date{24/04/2008}

\AtBeginSection[]

\begin{document}
 

\begin{frame}
%\frametitle{Presentación}
\titlepage
\end{frame}

\section{Memoria dinámica}
\begin{frame}
\frametitle{Memoria dinámica}
Existen dos tipos de memoria de dinámica disponibles en C++:
\begin{itemize}
 \item \emph{Stack}: Esta memoria se utiliza para las variables locales a las funciones y métodos. Este memoria será devuelta cuando la función finalice.
 \item \emph{Heap}: Con esto podemos obtener memoria para variables que necesitemos más allá del alcance de una función.
\end{itemize}

\end{frame}

\subsection{Heap}
\begin{frame}
\frametitle{Heap}
Para obtener y liberar memoria dinámica (de la Heap) tenemos dos instrucciones:
\begin{itemize}
 \item \emph{new}: Con esta instrucción pedimos memoria dinámica al sistema.
 \item \emph{delete}: Con esta instrucción devolvemos al sistema la memoria asignada a una variable
\end{itemize}

Podemos obtener memoria para:
\begin{itemize}
 \item Para crear objetos
 \item Para tipos básicos u otro tipo de datos.
\end{itemize}

\begin{block}{IMPORTANTE}
   La administración de la memoria pedida con los operadores \emph{new} y \emph{delete} es total responsabilidad del programador.
\end{block}

\end{frame}

\subsection{new}
\begin{frame}[fragile]
\frametitle{new}
Con el operador \emph{new} podemos pedir memoria para un objeto o tipo de datos.

El operador nos devuelve un puntero a la entidad recién construida. De ser necesario se pueden pasar los parámetros necesarios para el constructor.

\begin{verbatim}
   Casa *pCasa = new Casa;
\end{verbatim}

\end{frame}

\subsection{delete}
\begin{frame}
\frametitle{delete}

Con el operador \emph{delete} liberamos la memoria apuntada por el puntero que recibe como parámetro.
El destructor correspondiente a ese objeto es llamado y la memoria liberada.

\end{frame}

\subsection{Punteros}
\begin{frame}[fragile]
\frametitle{Punteros}

Un puntero nos permite un acceso indirecto a un objeto al cual esta apuntando.
Dependiendo al tipo de objeto que apunte, será el tipo de puntero.
Para definir un puntero usamos $*$ antes del nombre de la variable:

\begin{verbatim}
   int * pEntero = new int;
\end{verbatim}

¿Cómo accedemos al valor ``apuntado''?

El acceso al valor apuntado se llama desreferenciar y se puede hacer con el operador $*$:

\begin{verbatim}
   *pEntero = 5;
\end{verbatim}

\end{frame}


\begin{frame}[fragile]
\frametitle{Punteros - continuación}

\begin{verbatim}
    class Punto {
      public:
	  Punto(int x, int y);
	  int getX();
          int getY();
      private:
	  int _x, _y;
    };

    Punto * p = new Punto(10,10);
\end{verbatim}

Como puedo invocar al metodo \emph{getX} de \emph{p} ?

\begin{verbatim}
    std::cout "Pos X: " << (*p).getX() << std::endl;
\end{verbatim}

Como el acceso a miembros de una estructura o clase a partir de un puntero es una operación común, tenemos una manera abreviada de hacerlo:

\begin{verbatim}
    std::cout "Pos X: " << p->getX() << std::endl;
\end{verbatim}

\end{frame}


\begin{frame}[fragile]
\frametitle{Punteros - continuación}

Existe un valor especial que se le puede asignar a un puntero, de manera tal que cual intento de desreferenciarlo nos produzca un error.

Este valor es \emph{0}, a este valor se lo suele llamar puntero nulo (NULL POINTER).


\begin{block}
Cuando terminamos de usar un puntero o cuando todavía no tiene un valor definido, es buena costumbre asignarle el valor 0 a un puntero.
De esta manera podemos saber si tiene un valor valido o no.
\end{block}

\end{frame}



\begin{frame}[fragile]
\frametitle{Problemas con Punteros}
Los punteros suelen ser la fuente de los problemas más comunes de programación en C++:

\begin{itemize}
 \item Acceder a un puntero no inicializado o no valido (memoria ya devuelta al sistema).
 \item Perder o cambiarle el valor a un puntero que ya tiene un valor asignado.
\end{itemize}

El acceso a un puntero no valido puede provocar un comportamiento indifinido muy díficil de encontrar, inicializando correctamente los punteros y cargando el valor de puntero nulo si no tiene un valor actual es buena practica.

El perder el acceso a una variable dinámica nos produce una perdida de memoria (leak).

\end{frame}



\subsection{new [] y delete []}
\begin{frame}
\frametitle{new [] y delete []}

\end{frame}

\subsection{Leaks}
\begin{frame}
\frametitle{Leaks}

Las perdidas de memoria se producen 

\end{frame}

\section{Clases}

\subsection{operador this}
\begin{frame}
\frametitle{operador this}
  Este operador hace referencia a la instancia especifica de la clase y es válido solamente en los métodos de instancia de cualquier clase.

\end{frame}

\section{Herencia de clases}
\begin{frame}
\frametitle{Herencia de clases}
Herencia multiple.
\end{frame}

\subsection{Subclases}
\begin{frame}[fragile]
\frametitle{Subclases}

Para definir una subclase lo hacemos de la siguiente manera:

\begin{verbatim}

 class Cuadrado : public Figura {
 
 };
\end{verbatim}

\end{frame}

\subsection{Clases abstractas}
\begin{frame}
\frametitle{Clases abstractas}

 = 0 en los métodos.
\end{frame}

\subsection{Interfaces}
\begin{frame}
\frametitle{Interfaces}
  - Podemos usar la herencia multiple para definir interfaces
\end{frame}

\subsection{Métodos virtuales}
\begin{frame}
\frametitle{Métodos virtuales}
Que significa? 
Diferencias con otros lenguajes
\end{frame}

\subsection{Punteros y Polimorfismo}
\begin{frame}
\frametitle{Punteros y Polimorfismo}
\end{frame}


\end{document}

